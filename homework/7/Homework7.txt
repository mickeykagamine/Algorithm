1.	计算器（表达式计算-表达式树实现）
【问题描述】

从标准输入中读入一个整数算术运算表达式，如24 / ( 1 + 2 + 36 / 6 / 2 - 2) * ( 12 / 2 / 2 )= ，计算表达式结果，并输出。

要求：
1、表达式运算符只有+、-、*、/，表达式末尾的=字符表示表达式输入结束，表达式中可能会出现空格；
2、表达式中会出现圆括号，括号可能嵌套，不会出现错误的表达式；
3、出现除号/时，以整数相除进行运算，结果仍为整数，例如：5/3结果应为1。

4、要求采用表达式树来实现表达式计算。

表达式树（expression tree）：

我们已经知道了在计算机中用后缀表达式和栈来计算中缀表达式的值。在计算机中还有一种方式是利用表达式树来计算表达式的值。表达式树是这样一种树，其根节点为操作符，非根节点为操作数，对其进行中序遍历将计算表达式的值。由后缀表达式生成表达式树的方法如下：

l  读入一个符号：

l  如果是操作数，则建立一个单节点树并将指向他的指针推入栈中；

l  如果是运算符，就从栈中弹出指向两棵树T1和T2的指针（T1先弹出）并形成一棵新树，树根为该运算符，它的左、右子树分别指向T2和T1，然后将新树的指针压入栈中。

例如输入的后缀表达为：


    ab+cde+**

则生成的表达式树为：

 










 


【输入形式】

从键盘输入一个以=结尾的整数算术运算表达式。操作符和操作数之间可以有空格分隔。


【输出形式】

首先在屏幕上输出表达式树根、左子节点及右子节点上的运算符或操作数，中间由一个空格分隔，最后有一个回车（如果无某节点，则该项不输出）。然后输出表达式计算结果。
【样例输入】

24 / ( 1 + 2 + 36 / 6 / 2 - 2) * ( 12 / 2 / 2 )     =

【样例输出】

* / /

18


【样例说明】

按照运算符及括号优先级依次计算表达式的值。在生成的表达树中，*是根节点的运算符，/ 是根节点的左子节点上运算符，/是根节点的右子节点上运算符，按题目要求要输出。


【评分标准】

通过所有测试点得满分。


2.	词频统计（树实现）
【问题描述】

编写程序统计一个英文文本文件中每个单词的出现次数（词频统计），并将统计结果按单词字典序输出到屏幕上。

要求：程序应用二叉排序树（BST）来存储和统计读入的单词。

注：在此单词为仅由字母组成的字符序列。包含大写字母的单词应将大写字母转换为小写字母后统计。在生成二叉排序树不做平衡处理。

【输入形式】

打开当前目录下文件article.txt，从中读取英文单词进行词频统计。


【输出形式】

程序应首先输出二叉排序树中根节点、根节点的右节点及根节点的右节点的右节点上的单词（即root、root->right、root->right->right节点上的单词），单词中间有一个空格分隔，最后一个单词后没有空格，直接为回车（若单词个数不足三个，则按实际数目输出）。

程序将单词统计结果按单词字典序输出到屏幕上，每行输出一个单词及其出现次数，单词和其出现次数间由一个空格分隔，出现次数后无空格，直接为回车。

【样例输入】

当前目录下文件article.txt内容如下：

"Do not take to heart every thing you hear."

"Do not spend all that you have."

"Do not sleep as long as you want;"


【样例输出】

do not take

all 1

as 2

do 3

every 1

have 1

hear 1

heart 1

long 1

not 3

sleep 1

spend 1

take 1

that 1

thing 1

to 1

want 1

you 3


【样例说明】

程序首先在屏幕上输出程序中二叉排序树上根节点、根节点的右子节点及根节点的右子节点的右子节点上的单词，分别为do not take，然后按单词字典序依次输出单词及其出现次数。

【评分标准】

通过全部测试点得满分


3.	Huffman编码文件压缩
【问题描述】

编写一程序采用Huffman编码对一个正文文件进行压缩。具体压缩方法如下：

1.    对正文文件中字符(换行字符'\'除外，不统计)按出现次数（即频率）进行统计

2.    依据字符频率生成相应的Huffman树（未出现的字符不生成）

3.    依据Huffman树生成相应字符的Huffman编码

4.    依据字符Huffman编码压缩文件（即按照Huffman编码依次输出源文件字符）。

说明：

1.    只对文件中出现的字符生成Huffman，注意：一定不要处理\n，即不要为其生成Huffman码。

2.    采用ASCII码值为0的字符作为压缩文件的结束符（即可将其出现次数设为1来参与编码）.

3.    在生成Huffman树时，初始在对字符频率权重进行（由小至大）排序时，频率相同的字符ASCII编码值小的在前；新生成的权重节点插入到有序权重序列中时，出现相同权重时，插入到其后（采用稳定排序）。

4.    遍历Huffman树生成字符Huffman码时，左边为0右边为1。

5.    源文件是文本文件，字符采用ASCII编码，每个字符点8位；而采用Huffman编码后，高频字符编码长度较短（小于8位），因此最后输出时需要使用C语言中的位运算将字符Huffman码依次输出到每个字节中。


【输入形式】

对当前目录下文件input.txt进行压缩。


【输出形式】

将压缩后结果输出到文件output.txt中，同时将压缩结果用十六进制形式（printf("%x",...)）输出到屏幕上，以便检查和查看结果。

【样例输入1】

若当前目录下input.txt中内容如下：

aaabbc

【样例输出1】

15f0

 同时程序将压缩结果输出到文件output.txt中。


【样例说明】

输入文件中字符的频率为：a为3，b为2，c为1，此外，\0字符将作为压缩文件的结束标志，其出现次数设为1。因此，采用Huffman码生成方法，它们的Huffman编码分别为：

a : 0

b : 10

c : 111

\0 : 110

因此，最终文件压缩结果（按位）为：

0001010111110000

将上述结果按字节按十六进制输出到屏幕上则为15f0（即0001010 111110000的十六进制表示）。

说明：采用Huffman码输出字符序列长度为：1+1+1+2+2+3+3=13（位），由于C语言中输出的最小单位为字节（8位），因此，最后补了三个位0，压缩后实际输出为2个字节。由于文本文件是按ASCII来解释的，因此，以文本方式打开压缩文件将显示乱码（最好用二进制文件查看器来看）。

 

【样例输入2】


 

若当前目录下input.txt中内容如下：

do not spend all that you have.do not sleep as long as you want.

【样例输出2】

ea3169146ce9eee6cff4b2a93fe1a5d462d21d9a87c0eb2f3eb2a9cfe6cae


同时程序将压缩结果输出到文件output.txt中。

【评分标准】

通过所有测试点将得满分。